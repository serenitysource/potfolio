
<div align="center">
	<a href="https://github.serenity.energy" style="font-size:1.2em; font-weight:bold; color:#2d8cff;">
		ğŸ“– View Full Documentation Site: https://github.serenity.energy
	</a>
</div>

<div align="center">
	<h1>ğŸ” <span style="color:#2d8cff">End-to-End Provenance Flow</span> ğŸ”—</h1>
	<h3>Cryptographic Proof Chain for Energy Token Integrity</h3>
	<img src="https://img.shields.io/badge/Blockchain-Anchored-blue?logo=ethereum" />
	<img src="https://img.shields.io/badge/Provenance-Verified-green?logo=shield" />
	<img src="https://img.shields.io/badge/Audit-Ready-purple?logo=check-circle" />
	<img src="https://img.shields.io/badge/Merkle-Trees-orange?logo=tree" />
</div>

---

## ğŸ¯ System Goal (What Must Be Proven)

This system must provide three things at once:

| ğŸš€ **Real-time UX** | ğŸ”’ **Strong Provenance** | âš¡ **Minimal On-Chain Load** |
|---------------------|-------------------------|------------------------------|
| Users can transfer <span style="color:#2ecc71">**ERGON**</span>/<span style="color:#e67e22">**CARBON**</span> freely between wallets and bridge quickly | An auditor can later verify that <span style="color:#e67e22">**CARBON**</span> supply came from real device readings, with an integrity chain back to the device's metering database | On-chain storage is limited to anchors (cryptographic commitments) plus enough events to reconstruct proof paths, while detailed per-minute data remains off-chain (MQTT/DB) |

<div style="background-color: #e8f4f8; padding: 15px; border-left: 4px solid #2d8cff; margin: 15px 0;">
	<strong>ğŸ’¡ Key Idea:</strong> Keep minute-level readings in the database, but anchor each reading on-chain via a deterministic <code>canonical_reading_hash</code> and mint/burn events that reference it.
</div>

---

## ğŸ§© Components and Responsibilities

### ğŸŸ  A. HEPEK Device Runtime (`contract.py`)

- âœ… Reads meter deltas (minute granularity)
- âœ… Builds a canonical reading envelope
- âœ… Computes a deterministic `canonical_reading_hash` (`bytes32`, `keccak256`)
- âœ… Calls `ErgonEnergy.SC_Power_OUT_Alloc(produced, exported, canonical_reading_hash)` on-chain
- âœ… Persists the same hash and tx metadata in DB/MQTT for later audit reconstruction

### ğŸŸ£ B. Energy Accounting Contract (`ErgonEnergy.sol`)

- âœ… Receives readings and enforces anti-replay (e.g., `usedReading[readingHash]`)
- âœ… Emits audit events that include `canonical_reading_hash` and derived allocations
- âœ… Calls token contracts to mint/burn:
  - `Ergon.increaseSupply(...)`
  - `Carbon.increaseSupply(...)`
  - Burn calls for imports or settlement (depending on the accounting rules)

### ğŸŸ¢ C. ERC-20 Tokens (`Carbon.sol`, `Ergon.sol`)

- âœ… Hold balances and support normal ERC-20 transfers
- âœ… `increaseSupply(to, amount)` is the core mint entrypoint (in `Carbon.sol` it is typically restricted to `onlyEngine`)
- âœ… Burning is also restricted to `onlyEngine` (e.g., `burnFrom(...)`)

<div style="background-color: #fff3cd; padding: 15px; border-left: 4px solid #f39c12; margin: 15px 0;">
	<strong>âš¡ Separation of Concerns:</strong> This keeps token contracts simple while ensuring that all "meaning" (mint/burn justification) is derived from <code>ErgonEnergy</code> events.
</div>

---

## ğŸ”‘ Canonical Reading Hash (The Audit Anchor)

### ğŸ“Œ What the Hash Is (And Why It Matters)

`canonical_reading_hash` is the **cryptographic join key** across:

| Component | Purpose |
|-----------|---------|
| ğŸ—„ï¸ **Raw reading stored off-chain** | DB/MQTT telemetry data |
| â›“ï¸ **On-chain transaction** | Submission receipt |
| ğŸ“Š **On-chain audit/mint events** | Supply derivation proof |

**It exists to support:**

- ğŸ›¡ï¸ **Anti-replay**: The engine can reject a duplicate hash
- ğŸ”— **Cryptographic link**: Between telemetry records and EVM state transitions
- ğŸ” **Deterministic audit reconstruction**: Recompute the hash from DB data and match it to chain events

<div style="background-color: #d4edda; padding: 15px; border-left: 4px solid #28a745; margin: 15px 0;">
	<strong>ğŸ“ Note:</strong> Solidity code may refer to this value as <code>readingHash</code> or <code>reading_hash</code> as a parameter name; this document consistently uses <code>canonical_reading_hash</code> for clarity.
</div>

### ğŸ” Deterministic Hashing: Prefer the "Strong" Version

Two hashing approaches typically exist:

| Approach | Characteristics |
|----------|----------------|
| âš ï¸ **Minimal Payload** | `make_reading_hash(...)` - Basic fields only |
| âœ… **Strong & Deterministic** | `make_deterministic_reading_hash(...)` - Typed + normalized + schema + direction + factor |

The **deterministic version** is safer because it enforces:

- âœ… Device ID normalization
- âœ… Timestamp as an integer slot (no format ambiguity)
- âœ… Produced/exported values as integers (avoids float drift)
- âœ… A schema/version marker
- âœ… Canonical JSON encoding with stable separators

<div style="background-color: #e8f4f8; padding: 15px; border-left: 4px solid #2d8cff; margin: 15px 0;">
	<strong>ğŸ¯ Auditor Requirement:</strong> The digest can be reproduced <em>exactly</em> from the same source data.
</div>

### ğŸ“¦ Should `canonical_reading_hash` Be Included in MQTT Payload?

**Yes.** The intended pattern is:

- **â›“ï¸ On-chain:** store/emit `canonical_reading_hash`
- **ğŸ—„ï¸ Off-chain:** store:
  - `canonical_reading_hash` (same value)
  - the original meter fields
  - transaction metadata (`tx_hash`, and ideally block/log position)

#### ğŸ—‚ï¸ Recommended Audit-Friendly DB Fields (Per Reading)

| # | Field Name | Description |
|---|------------|-------------|
| 1 | `canonical_reading_hash` | bytes32 hex |
| 2 | `device_id` | normalized lowercase address |
| 3 | `timestamp_slot` | epoch-minute `int` |
| 4 | `produced_power` | integer value |
| 5 | `export_power` | integer value |
| 6 | `factor` | allocation factor |
| 7 | `direction` | energy flow direction |
| 8 | `chain_id` | blockchain network ID |
| 9 | `tx_hash` | transaction hash |
| 10 | `block_number` | block number |
| 11 | `log_index` | index of the engine audit event log |
| 12 | `ergon_energy_contract` | contract address |
| 13 | `prev_hash` | (optional) previous reading hash for chaining |

<div style="background-color: #d4edda; padding: 15px; border-left: 4px solid #28a745; margin: 15px 0;">
	<strong>âœ… Result:</strong> This makes provenance reconstruction deterministic and fast.
</div>

---

## ğŸ”„ End-to-End Flow (Minute Reading â†’ Tokens Minted)

### ğŸ“Š High-Level Block Diagram

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      MQTT/DB write (payload + canonical_reading_hash + tx_meta)
â”‚   HEPEK      â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  device      â”‚                                                            â”‚
â”‚ contract.py  â”‚                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                                                            â”‚
       â”‚ SC_Power_OUT_Alloc(produced, exported, canonical_reading_hash)     â”‚
       â–¼                                                                    â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         mints/burns              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  ErgonEnergy.sol  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚  Carbon.sol    â”‚    â”‚
â”‚  (engine + audit) â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚  Ergon.sol     â”‚    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
       â”‚                                                                    â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€ emits audit events (canonical_reading_hash anchored) â”€â”€â”€â”€â”€â”˜
```

### ğŸ”¢ Detailed Step-by-Step Sequence

<details>
<summary><strong>Click to expand full sequence</strong></summary>

1. **ğŸ—ï¸ Device creates envelope + hash**
   - Build a canonical envelope with `device_id`, `timestamp`, `direction`, `produced/exported`, and `factor`
   - Compute `canonical_reading_hash = make_deterministic_reading_hash(envelope)`

2. **ğŸ“¤ Device submits reading to chain**
   - Invoke `SC_Power_OUT_Alloc(produced_power, export_power, canonical_reading_hash)` (signed by the device key)

3. **ğŸ’¾ Device stores DB/MQTT record**
   - After receipt, persist `canonical_reading_hash` and the originating `tx_hash` with the telemetry payload

4. **ğŸ›¡ï¸ Engine validates anti-replay**
   - `ErgonEnergy` checks its anti-replay mapping and rejects duplicates

5. **ğŸ“¢ Engine emits audit events**
   - `ErgonEnergy` emits events that include:
     - the anchor (`canonical_reading_hash`)
     - the measured inputs (produced/exported)
     - derived allocations / rule flags
     - minted token quantities

6. **ğŸ’° Engine mints tokens**
   - `ErgonEnergy` calls token contracts:
     - `Ergon.increaseSupply(user_or_device, ergonAmount)`
     - `Carbon.increaseSupply(user_or_device, carbonAmount)`

</details>

<div style="background-color: #e8f4f8; padding: 15px; border-left: 4px solid #2d8cff; margin: 15px 0;">
	<strong>ğŸ“– Interpretation:</strong> "This amount of <span style="color:#e67e22"><strong>CARBON</strong></span> exists because this specific <code>canonical_reading_hash</code> was accepted and allocated by the engine."
</div>

---

## ğŸ“¡ What to Emit On-Chain (And Why)

Auditors need evidence that:

- âœ… Readings existed
- âœ… Readings were not replayed
- âœ… Minting was derived from readings
- âœ… Later burns (for certificates) correspond to real minted supply

### ğŸ¯ Minimum Event Set (Recommended)

For each accepted reading, emit one canonical engine audit event (e.g., `ReadingAccepted`):

```solidity
event ReadingAccepted(
    address indexed device,
    uint256 indexed timestamp_slot,
    bytes32 indexed canonical_reading_hash,
    uint256 produced,
    uint256 exported,
    uint256 factor,
    uint256 ergon_minted,
    uint256 carbon_minted,
    uint8 reason_code  // Optional: rule_flags
);
```

#### âœ¨ Benefits

| Benefit | Description |
|---------|-------------|
| ğŸ” **Reconstruction** | Enables reconstruction of supply provenance per reading without storing raw telemetry on-chain |
| ğŸ”— **Linkage** | ERC-20 minting already produces standard `Transfer(0x0 â†’ to, amount)` logs, but the engine event is what ties mint amounts to `canonical_reading_hash` |
| ğŸ“Š **Audit Trail** | Complete on-chain audit trail linking readings to token supply |

### âš ï¸ Why Not "Minute Lots" On-Chain

Bridge slowdowns are a common failure mode when too much fine-grained provenance is pushed into the bridged representation.

<div style="background-color: #fff3cd; padding: 15px; border-left: 4px solid #f39c12; margin: 15px 0;">
	<strong>ğŸ“ Auditor Insight:</strong> An auditor typically does not require "minute provenance on the bridged chain". Instead, they require:
	<ul>
		<li>âœ… Proof that the source chain contains immutable anchors</li>
		<li>âœ… A provable mapping from certificate retirement (burn) â†’ subset of those anchors</li>
	</ul>
</div>

**So:**

- âœ… Keep minute anchors in the source chain + DB
- âœ… Optionally aggregate into period commitments (daily/monthly) for fast proofs
- âœ… Bridge only ERC-20 balances for UX

---

## ğŸš€ Provenance Model That Stays Fast for Users

The design targets:

- âš¡ Fast transfers/bridging in real time
- ğŸ“¦ Minimal on-chain data sufficient for audit
- ğŸ¯ The ability to prove device contributions at certificate mint/retirement time (e.g., "20% device A, rest devices B..F")

### ğŸ§  Correct Mental Model: Balances Move, Provenance Stays Anchored

ERC-20 transfers do not need to "move provenance lots". Provenance is not "which user owns which reading"; provenance is "what evidence created this supply".

**Model:**

```mermaid
graph LR
    A[Source Chain] -->|Immutable Anchors| B[Reading Events]
    B -->|Mints| C[CARBON Supply]
    C -->|Free Transfer| D[User Wallets]
    D -->|Certificate Mint| E[NFT with Proof]
    E -->|Burn CARBON| F[Retired Supply]
    F -->|Audit Trail| B
    
    style A fill:#2d8cff,color:#fff
    style C fill:#2ecc71,color:#fff
    style E fill:#9b59b6,color:#fff
```

- ğŸ”— **Source chain** stores immutable reading anchors/events
- ğŸ’° **CARBON token supply** exists because those anchors existed
- ğŸ”„ Users can trade CARBON freely
- ğŸ† When minting an NFT certificate (burning CARBON), generate an audit proof showing the burned amount is covered by a set of anchors (or period commitments)

---

## ğŸŒ³ Period Commitments (Optional But Powerful)

This is the "middle layer" between minute anchors and certificate proofs.

### ğŸ“… What `commitDevicePeriod(device, periodId, periodSum, periodRoot)` Means

For a device and a period (day/week/month), compute:

| Parameter | Description |
|-----------|-------------|
| `periodSum` | Total carbon minted for that device in that period (or total kWh / total carbon delta) |
| `periodRoot` | A Merkle root over all reading anchors, typically leaves such as `(canonical_reading_hash, carbon_amount)` |

Store these commitments on-chain (mapping + event):

```solidity
// Mappings
mapping(address => mapping(uint256 => DevicePeriodCommit)) public devicePeriodCommit;

struct DevicePeriodCommit {
    uint256 sum;
    bytes32 root;
}

// Event
event DevicePeriodCommitted(
    address indexed device,
    uint256 indexed periodId,
    uint256 periodSum,
    bytes32 periodRoot
);
```

### ğŸŒ What `commitPeriodGlobal(periodId, globalRoot)` Means

For a given period, compute a Merkle root over all device commitments for that period (e.g., leaves are `(device, sum, root)`).

Then store:

```solidity
mapping(uint256 => bytes32) public globalCommit;

event PeriodGlobalCommitted(
    uint256 indexed periodId,
    bytes32 globalRoot
);
```

**Verification Flow:**

```mermaid
graph TD
    A[Global Period Root] --> B1[Device A Period Root]
    A --> B2[Device B Period Root]
    A --> B3[Device C Period Root]
    B1 --> C1[Reading 1]
    B1 --> C2[Reading 2]
    B1 --> C3[Reading 3]
    B2 --> C4[Reading 4]
    B2 --> C5[Reading 5]
    B3 --> C6[Reading 6]
    
    style A fill:#9b59b6,color:#fff
    style B1 fill:#2d8cff,color:#fff
    style B2 fill:#2d8cff,color:#fff
    style B3 fill:#2d8cff,color:#fff
    style C1 fill:#2ecc71,color:#fff
    style C2 fill:#2ecc71,color:#fff
    style C3 fill:#2ecc71,color:#fff
    style C4 fill:#2ecc71,color:#fff
    style C5 fill:#2ecc71,color:#fff
    style C6 fill:#2ecc71,color:#fff
```

<div style="background-color: #d4edda; padding: 15px; border-left: 4px solid #28a745; margin: 15px 0;">
	<strong>âœ… Now an auditor can verify:</strong>
	<ul>
		<li>The certificate burn was covered by a set of device periods</li>
		<li>Each device period is covered by a set of per-reading anchors (if needed)</li>
	</ul>
</div>

### â° Should This Be Executed Automatically When the Period Elapses?

EVM contracts do not self-trigger when time passes.

So "automatic" must be off-chain (cron job / relayer / keeper bot). A typical pattern:

1. ğŸ¤– **Relayer wakes** every N minutes/hours
2. ğŸ“† **Detects** a period boundary
3. ğŸ§® **Computes** commits (from DB/indexer)
4. ğŸ“¤ **Calls** `commitDevicePeriod` and `commitPeriodGlobal`

---

## ğŸŒ‰ Bridging: Keep It Agnostic to Lots/Periods (Best for UX)

### ğŸ¤” Do We Need to Sync Period Commits to Destination Chain Periodically?

Not strictly. Two common options:

<table>
<tr>
<td style="background-color: #d4edda; padding: 15px; width: 50%;">

### âœ… Option A â€” No Periodic Sync (Simplest UX)

**Recommended for fast & frictionless UX**

- Bridge only moves ERC-20 balances
- Destination chain treats the source chain as the provenance authority
- When an NFT certificate is minted (destination or source), fetch proofs from the source (or from DB/indexer) and embed proof/roots into NFT metadata / certificate events

**Pros:**
- âš¡ Fastest bridging
- ğŸ¯ Simplest implementation
- ğŸ’° Lowest gas costs

</td>
<td style="background-color: #fff3cd; padding: 15px; width: 50%;">

### âš ï¸ Option B â€” Periodic Sync (Self-Contained Destination)

**Alternative for regulatory requirements**

- Relayer periodically sends `(periodId, globalRoot)` (and optionally device commits) to destination
- Destination contract stores these roots
- NFT mint on destination can verify proofs against stored roots without querying the source

**Pros:**
- ğŸ”’ Self-contained verification
- ğŸ“Š On-chain audit trail on destination
- ğŸ›ï¸ May satisfy certain regulatory requirements

</td>
</tr>
</table>

<div style="background-color: #e8f4f8; padding: 15px; border-left: 4px solid #2d8cff; margin: 15px 0;">
	<strong>ğŸ’¡ Recommendation:</strong> If the priority is "fast and frictionless", Option A is usually sufficient unless a regulator explicitly requires destination-chain self-verification.
</div>

### ğŸ”— What Does Destination Need During `bridgeMint`?

If the destination token represents bridged CARBON balance, it does not need device lists at mint time.

It typically only needs:

```solidity
function bridgeMint(
    bytes32 messageId,
    address recipient,
    uint256 amount,
    bytes calldata proof  // Optional: ZK or gateway proof
) external onlyBridge {
    _mint(recipient, amount);
    emit BridgeMinted(messageId, recipient, amount);
}
```

**Parameters:**

- `messageId` â€” Unique bridge message identifier
- `recipient` â€” Destination wallet address
- `amount` â€” Amount of tokens to mint
- `proof` â€” Optional proof blob for bridge authentication

<div style="background-color: #fff3cd; padding: 15px; border-left: 4px solid #f39c12; margin: 15px 0;">
	<strong>ğŸ“ Note:</strong> Provenance proofs can be handled later at certificate mint / retirement time.
</div>

---

## ğŸ”— Stronger Provenance with Hash Chaining (Optional Upgrade)

To detect missing readings (even off-chain), add:

| Field | Purpose |
|-------|---------|
| `seq` | Monotonic counter per device |
| `prev_hash` | Hash of previous reading |

Then each reading anchor commits to a chain:

```solidity
canonical_reading_hash_t = keccak256(
    abi.encodePacked(
        device,
        timestamp,
        produced,
        exported,
        factor,
        seq,
        prev_hash_{t-1}
    )
);
```

### ğŸ”— Sequential Hash Chain Visualization

```mermaid
graph LR
    A[Reading 1<br/>seq=1<br/>prev=0x0] -->|hash1| B[Reading 2<br/>seq=2<br/>prev=hash1]
    B -->|hash2| C[Reading 3<br/>seq=3<br/>prev=hash2]
    C -->|hash3| D[Reading 4<br/>seq=4<br/>prev=hash3]
    D -->|hash4| E[...]
    
    style A fill:#2ecc71,color:#fff
    style B fill:#2ecc71,color:#fff
    style C fill:#2ecc71,color:#fff
    style D fill:#2ecc71,color:#fff
    style E fill:#95a5a6,color:#fff
```

<div style="background-color: #d4edda; padding: 15px; border-left: 4px solid #28a745; margin: 15px 0;">
	<strong>âœ… Benefit:</strong> This makes gaps or tampering detectable even if a record is deleted from the DB.
</div>

**Implementation:**

```solidity
// Store previous hash per device
mapping(address => bytes32) public deviceLastHash;
mapping(address => uint256) public deviceSequence;

function validateChainedReading(
    address device,
    uint256 seq,
    bytes32 prev_hash,
    bytes32 canonical_reading_hash
) internal {
    require(seq == deviceSequence[device] + 1, "Invalid sequence");
    require(prev_hash == deviceLastHash[device], "Broken chain");
    
    deviceSequence[device] = seq;
    deviceLastHash[device] = canonical_reading_hash;
}
```

---

## ğŸ“ Summary

<div style="background-color: #e8f4f8; padding: 20px; border-left: 5px solid #2d8cff; margin: 20px 0;">

### ğŸ¯ Key Takeaways

Each meter interval is anchored using a deterministic `canonical_reading_hash` computed from a canonicalized payload (device identifier, epoch time slot, measured production/export values, and allocation factor). The device submits the `canonical_reading_hash` to the on-chain energy engine (`ErgonEnergy`) together with the measured deltas. The engine enforces anti-replay and emits immutable audit events binding each accepted reading to the derived allocations and token mint amounts. The same `canonical_reading_hash` is persisted in MQTT/DB alongside the transaction metadata, enabling deterministic cross-verification between off-chain telemetry and on-chain state transitions. This keeps detailed per-minute telemetry off-chain for scale, while keeping on-chain evidence sufficient for audit.

### âœ… Is `canonical_reading_hash` Enough?

**Yes**, if it is:

- âœ… **Deterministic** (typed + normalized)
- âœ… **Stored in DB** alongside the raw reading and tx metadata
- âœ… **Referenced by an on-chain audit event** that ties it to mint/burn outcomes

</div>

---

## ğŸ“š Glossary

<details>
<summary><strong>Click to expand glossary</strong></summary>

| Term | Icon | Definition |
|------|------|------------|
| **`canonical_reading_hash`** | ğŸ”‘ | A deterministic `bytes32` anchor (typically `keccak256`) computed from a canonical reading envelope. Used as the cross-system join key for telemetry records, EVM transactions, and engine audit events. |
| **Reading envelope** | ğŸ“¦ | The canonical set of fields hashed to produce `canonical_reading_hash` (e.g., normalized `device_id`, `timestamp_slot`, `produced/exported`, `factor`, and a schema/version marker). |
| **`timestamp_slot`** | â° | The reading time represented as an integer slot (commonly "epoch minute") to avoid ambiguity. |
| **Engine audit event** | ğŸ“¢ | A contract event emitted by `ErgonEnergy` that ties an accepted reading anchor to derived allocations and mint/burn outcomes. |
| **Anti-replay** | ğŸ›¡ï¸ | A contract rule that rejects a previously-seen reading anchor (e.g., using a `usedReading` mapping). |
| **`periodId`** | ğŸ“… | A period identifier (day/week/month) used for aggregating per-minute anchors into period commitments. |
| **`periodSum`** | ğŸ“Š | The aggregate amount for a device over a period (e.g., total CARBON minted). |
| **`periodRoot`** | ğŸŒ³ | A Merkle root committing to all per-reading anchors in a period (often leaves like `(canonical_reading_hash, carbon_amount)`). |
| **`globalRoot`** | ğŸŒ | A Merkle root committing to all device period commitments for a period (often leaves like `(device, sum, root)`). |
| **ERGON** | âš¡ | Energy token representing generated power |
| **CARBON** | ğŸŒ¿ | Carbon credit token for renewable energy |
| **Hash chaining** | ğŸ”— | Sequential linking of readings using previous hash and sequence number |
| **Merkle tree** | ğŸŒ³ | Binary tree structure for efficient cryptographic proofs |

</details>

---

<div align="center">
	<h2>ğŸš€ Ready to Build Trustless Energy Systems</h2>
	<p><strong>Made with ğŸ’š by the Serenity Energy Team</strong></p>
	<img src="https://img.shields.io/badge/Blockchain-Anchored-blue?logo=ethereum" />
	<img src="https://img.shields.io/badge/Provenance-Verified-green?logo=shield" />
	<img src="https://img.shields.io/badge/Audit-Ready-purple?logo=check-circle" />
	<img src="https://img.shields.io/badge/Web3-Enabled-orange?logo=web3dotjs" />
</div>
